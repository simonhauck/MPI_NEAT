% !TeX spellcheck = de_DE
\section{Erkenntnisse}
\label{sec:analysis_results}
Nach Darstellung der Optimierungsprobleme erfolgt eine Zusammenfassung der Ergebnisse in diesem Kapitel. Alle vorgestellten Optimierungsverfahren konnten durch die Schnittstelle der Bibliothek schnell und einfach implementiert werden. Dies trifft sowohl auf individuell erstellte Optimierungsprobleme als auch auf Standardprobleme aus dem OpenAI Gym zu. Auch die restlichen Anforderungen aus Kapitel \ref{sec:requirements} sind vollständig implementiert. Der gesamte Ablauf des Algorithmus kann mithilfe eines spezifizierten \emph{Seeds} beeinflusst und wiederholt werden. Die verschiedenen Abbildungen im vorherigen Kapitel zeigen, dass die Testergebnisse der Trainingsverfahren gemessen, visualisiert und gespeichert werden können, sodass ein späterer Vergleich mit der parallelisierten Implementierung möglich ist.
\\\\
Die Funktionalität des Algorithmus, neue Strukturen zu entwickeln und zu optimieren, ist mit dem XOR-Problem bewiesen. Mit derselben Konfiguration werden im Vergleich zur originalen Implementierung ähnliche Ergebnisse gemessen. Durch verschiedene Anpassungen konnten bei nachfolgenden Versuchen sogar bedeutend bessere Ergebnisse erzielt werden. Bei Betrachtung der Ausführungszeit ist in diesem Beispiel ist die Zeit zum Erstellen und Mutieren von Nachkommen der größte Faktor. Aber da das XOR-Problem insgesamt sehr einfach ist und somit aufwendigere Probleme nicht richtig repräsentiert, finden die Ergebnisse im weiteren Verlauf keine Beachtung.
\\\\
Im nächsten Schritt wurden daher die \emph{Cartpole}, \emph{Mountain Car} und \emph{Pendulum} Umgebung des OpenAI Gyms implementiert, welche aufwändiger zu lösen sein sollten als das XOR-Problem. Die Tests haben ergeben, dass die erste Umgebung ungeeignet ist, da bereits die zufällig erstellten \ac{KNN} der ersten Generation das Optimierungsproblem lösen können. Dies trifft nicht auf die zwei anderen Umgebungen zu. Im vorgestellten Szenario wurden für die erste Umgebung $105$ Minuten, für die zweite Umgebung $125$ Minuten zur erfolgreichen Optimierung benötigt. Zwar hat \ac{NEAT} beide Probleme erfolgreich gelöst, dennoch werden die Grenzen des Algorithmus aufgezeigt. Vor allem auf dem Raspberry Pi sind die benötigten Optimierungszeiten für verhältnismäßig kleine Probleme sehr hoch. Große Optimierungsprobleme, bei denen die Eingabevektoren aus mehreren tausend Werten bestehen, können aufgrund der begrenzten Rechenleistung nicht oder nur mit sehr hohem Zeitaufwand optimiert werden. Da der Fokus dieser Arbeit auf dem Vergleich zwischen einer sequenziellen und parallelisierten Implementierung liegt, ist dieser Umstand zu vernachlässigen.
\\\\
Bei Betrachtung der Ausführungszeiten ist sowohl für das \emph{Mountain Car} und \emph{Pendulum} Problem ersichtlich, dass die Evaluationsphase der größte Faktor ist. In der ersten Umgebung wurden $98\%$, in der zweiten $91\%$ der Ausführungszeit für das Erstellen und Evaluieren von \ac{KNN} verwendet. Da im Falle einer erfolgreichen Parallelisierung in dieser Phase die meiste Ausführungszeit eingespart werden kann, liegt der Fokus im folgenden Kapitel primär darauf. Für die eigentliche Parallelisierung ist wichtig, dass nicht nur die Berechnungen des \ac{KNN} optimiert werden. Im Rahmen der \emph{Evaluation Time} wird neben der benötigten Zeit zum Erstellen und Aktivieren eines \ac{KNN} auch die benötigte Zeit zum Simulieren der Umgebung gemessen. Diese kann einen großen Einfluss auf das Gesamtergebnis haben. An zweiter und dritter Stelle der Priorisierung stehen die Parallelisierungen der Funktionen in den Phasen \emph{Compose Offspring Time} und \emph{Reproduction Time}. Beide haben einen bedeutend geringeren Anteil an der gesamten Ausführungszeit und dementsprechend weniger Zeit kann eingespart werden. Ob und wie diese implementiert werden können, wird in den Kapiteln (TODO KAPITEL!) erläutert. % TODO Kapitel
\\\\
Zuletzt soll betont werden, dass bei den vorstellten Optimierungsproblemen keine generelle Lösungsstrategie entwickelt wird. Hierfür müssten verschiedene Startsituationen in der Evaluationsphase getestet werden, indem beispielsweise jeder Agent in $x$ verschiedenen Umgebungen getestet und der mittlere Fitnesswert verwendet wird. Dies würde die Evaluationszeit um den Faktor $x$ erhöhen, was im gegebenen Anwendungsszenario eine Analyse bedeutend aufwändiger gestalten würde. Mit der parallelisierten Version in Kapitel (TODO KAPITEL) kann ein solches Verfahren umgesetzt und ein entsprechendes \ac{KNN} schneller entwickelt werden.

